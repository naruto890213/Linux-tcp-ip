|-->ip_fast_csum //(arch/x86/include/asm/checksum_64.h) 根据 arch 架构来划分为不同的处理
	|-->asm("  movl (%1), %0\n"
        "  subl $4, %2\n"
        "  jbe 2f\n"
        "  addl 4(%1), %0\n"
        "  adcl 8(%1), %0\n"
        "  adcl 12(%1), %0\n"
        "1: adcl 16(%1), %0\n"
        "  lea 4(%1), %1\n"
        "  decl %2\n"
        "  jne  1b\n"
        "  adcl $0, %0\n"
        "  movl %0, %2\n"
        "  shrl $16, %0\n"
        "  addw %w2, %w0\n"
        "  adcl $0, %0\n"
        "  notl %0\n"
        "2:"
        : "=r" (sum), "=r" (iph), "=r" (ihl)
        : "1" (iph), "2" (ihl)
        : "memory"); //使用汇编进行处理，加快处理速度
		
    |-->return (__force __sum16)sum

|-->inet_init //(net/ipv4/af_inet.c) 
	|-->ip_init //(net/ipv4/ip_output.c) 协议初始化
		|-->ip_rt_init()
		|-->inet_initpeers()
		|-->igmp_mc_init()
		
|-->static __net_initdata struct pernet_operations sysctl_route_ops = {
    .init = sysctl_route_net_init,
    .exit = sysctl_route_net_exit,
};//(net/ipv4/route.c)
		
|-->static __net_initdata struct pernet_operations rt_genid_ops = {
    .init = rt_genid_init,
};//(net/ipv4/route.c)

|-->static __net_initdata struct pernet_operations ipv4_inetpeer_ops = {
    .init   =   ipv4_inetpeer_init,
    .exit   =   ipv4_inetpeer_exit,
};

|-->static struct dst_ops ipv4_dst_ops = {
    .family =       AF_INET,
    .check =        ipv4_dst_check,
    .default_advmss =   ipv4_default_advmss,
    .mtu =          ipv4_mtu,
    .cow_metrics =      ipv4_cow_metrics,
    .destroy =      ipv4_dst_destroy,
    .negative_advice =  ipv4_negative_advice,
    .link_failure =     ipv4_link_failure,
    .update_pmtu =      ip_rt_update_pmtu,
    .redirect =     ip_do_redirect,
    .local_out =        __ip_local_out,
    .neigh_lookup =     ipv4_neigh_lookup,
    .confirm_neigh =    ipv4_confirm_neigh,
};//(net/ipv4/route.c)
		
|-->ip_rt_init //(net/ipv4/route.c) ipv4路由初始化
	|-->ip_idents = kmalloc(IP_IDENTS_SZ * sizeof(*ip_idents), GFP_KERNEL)
	|-->prandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents))
	|-->ip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL)
	|-->for_each_possible_cpu(cpu) //根据cpu的个数进行设置
		|-->struct uncached_list *ul = &per_cpu(rt_uncached_list, cpu)
		|-->INIT_LIST_HEAD(&ul->head)
		|-->spin_lock_init(&ul->lock)
		
	|-->ipv4_dst_ops.kmem_cachep = kmem_cache_create("ip_dst_cache", sizeof(struct rtable), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL)
	|-->ipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep
	|-->dst_entries_init(&ipv4_dst_ops)
	|-->dst_entries_init(&ipv4_dst_blackhole_ops)
	|-->devinet_init()
	|-->ip_fib_init()
	|-->ip_rt_proc_init()
	|-->xfrm_init()
	|-->xfrm4_init()
	|-->rtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL, RTNL_FLAG_DOIT_UNLOCKED)
	|-->register_pernet_subsys(&sysctl_route_ops)
	|-->register_pernet_subsys(&rt_genid_ops)
	|-->register_pernet_subsys(&ipv4_inetpeer_ops)
	
|-->devinet_init //(net/ipv4/devinet.c) devinet初始化
	|-->for (i = 0; i < IN4_ADDR_HSIZE; i++)
		|-->INIT_HLIST_HEAD(&inet_addr_lst[i])
		
	|-->register_pernet_subsys(&devinet_ops)
	|-->register_gifconf(PF_INET, inet_gifconf)
	|-->register_netdevice_notifier(&ip_netdev_notifier)
	|-->queue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0)
	|-->rtnl_af_register(&inet_af_ops)
	|-->rtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, 0)
	|-->rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, 0)
	|-->rtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, 0)
	
|-->static struct pernet_operations ip_rt_proc_ops __net_initdata =  {
    .init = ip_rt_do_proc_init,
    .exit = ip_rt_do_proc_exit,
};
	
|-->ip_rt_proc_init //(net/ipv4/route.c) //proc文件目录创建
	|-->register_pernet_subsys(&ip_rt_proc_ops)
	
|-->inet_initpeers //(net/ipv4/inetpeer.c)

|-->ip_rcv //(net/ipv4/ip_input.c) IP封包接收处理函数
	|-->if (skb->pkt_type == PACKET_OTHERHOST) //当数据帧的L2目的地址和接收地址接口不同时直接将数据丢弃
		|-->goto drop
		
	|-->net = dev_net(dev)
	|-->__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb->len)
	|-->skb = skb_share_check(skb, GFP_ATOMIC) //检查该数据包使用有其他引用
	|-->if (!pskb_may_pull(skb, sizeof(struct iphdr)))
		|-->goto inhdr_error
		
	|-->iph = ip_hdr(skb)
	|-->if (iph->ihl < 5 || iph->version != 4)
		|-->goto inhdr_error
		
	|-->if (!pskb_may_pull(skb, iph->ihl*4))
		|-->goto inhdr_error
		
	|-->iph = ip_hdr(skb)
	|-->if (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))
		|-->goto csum_error
		
	|-->len = ntohs(iph->tot_len)
	|-->if (skb->len < len)
		|-->goto drop	
	|-->else if (len < (iph->ihl*4))
		|-->goto inhdr_error
		
	|-->if (pskb_trim_rcsum(skb, len))
		|-->goto drop
		
	|-->skb->transport_header = skb->network_header + iph->ihl*4
	|-->memset(IPCB(skb), 0, sizeof(struct inet_skb_parm))
	|-->IPCB(skb)->iif = skb->skb_iif
	|-->skb_orphan(skb)
	|-->return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
               net, NULL, skb, dev, NULL,
               ip_rcv_finish) //进入iptables的节点，如果通过了PREROUTING则进入 ip_rcv_finish
			   
|-->pskb_may_pull //(include/linux/skbuff.h) 确保skb->data所指区域包含的数据区块至少和IP报头一样大
	|-->if (likely(len <= skb_headlen(skb)))
		return 1
	|-->if (unlikely(len > skb->len))
		|-->return 0
	|-->__pskb_pull_tail(skb, len - skb_headlen(skb)) != NULL
	
|-->struct iphdr {
    __u8    	version:4,
				ihl:4;
    __u8    	tos;
    __be16  	tot_len;
    __be16  	id;
    __be16  	frag_off;
    __u8    	ttl;
    __u8    	protocol;
    __sum16 	check;
    __be32  	saddr;
    __be32  	daddr;
}; //(include/uapi/linux/ip.h)

|-->struct ip_options {
    __be32      	faddr;
    __be32      	nexthop;
    unsigned char   optlen;
    unsigned char   srr;
    unsigned char   rr;
    unsigned char   ts;
    unsigned char   is_strictroute:1,
					srr_is_hit:1,
					is_changed:1,
					rr_needaddr:1,
					ts_needtime:1,
					ts_needaddr:1;
    unsigned char   router_alert;
    unsigned char   cipso;
    unsigned char   __pad2;
    unsigned char   __data[0];
}; //(include/net/inet_sock.h)
	
|-->ip_hdr //(include/linux/ip.h) 结构体转化函数
	|-->(struct iphdr *)skb_network_header(skb)

|-->skb_network_header //(include/linux/skbuff.h)
	|-->skb->head + skb->network_header
	
|-->pskb_trim_rcsum //(include/linux/skbuff.h) //L2协议长度校验剪切
	|-->if (likely(len >= skb->len))
		|-->return 0
	|-->if (skb->ip_summed == CHECKSUM_COMPLETE)
		|-->skb->ip_summed = CHECKSUM_NONE
	|-->return __pskb_trim(skb, len)
	
|-->__pskb_trim //(include/linux/skbuff.h)
	|-->if (skb->data_len)
		|-->return ___pskb_trim(skb, len)
		
	|-->__skb_trim(skb, len)

|-->ip_rcv_finish //(net/ipv4/ip_input.c)
	|-->ip_route_input_noref //(net/ipv4/route.c)	
		|-->ip_route_input_rcu //(net/ipv4/route.c)	
			|-->ip_route_input_slow //(net/ipv4/route.c)
				|-->switch(goto) //根据不同的情况走向不同的分支
					|-->case forward: //进行抓发
						|-->ip_mkroute_input //(net/ipv4/route.c)
							|-->__mkroute_input //(net/ipv4/route.c)
								|-->rth->dst.input = ip_forward //设置回调函数
								
					|-->case local_input: //发往本地
						|-->rt_dst_alloc //(net/ipv4/route.c)
							|-->rt->dst.input = ip_local_deliver //发往本地
		
|-->ip_rcv_finish //(net/ipv4/ip_input.c) 通过PREROUTING链后的数据处理
	|-->skb = l3mdev_ip_rcv(skb)
	|-->if (!skb)
		|-->return NET_RX_SUCCESS
		
	|-->if (net->ipv4.sysctl_ip_early_demux &&
			!skb_dst(skb) &&
			!skb->sk &&
			!ip_is_fragment(iph))
		|-->int protocol = iph->protocol
		|-->ipprot = rcu_dereference(inet_protos[protocol])
		|-->if (ipprot && (edemux = READ_ONCE(ipprot->early_demux)))
			|-->iph = ip_hdr(skb)
			
	|-->if (!skb_valid_dst(skb))
		|-->ip_route_input_noref(skb, iph->daddr, iph->saddr, iph->tos, dev)
		
	|-->if (iph->ihl > 5 && ip_rcv_options(skb))
		|-->goto drop
		
	|-->rt = skb_rtable(skb)
	|-->if (rt->rt_type == RTN_MULTICAST)
		|-->__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb->len)
	|-->else if (rt->rt_type == RTN_BROADCAST)
		|-->__IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb->len)
	|-->else if (skb->pkt_type == PACKET_BROADCAST || skb->pkt_type == PACKET_MULTICAST)
		|-->struct in_device *in_dev = __in_dev_get_rcu(dev)
		|-->if (in_dev && IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))
			|-->goto drop
			
	|-->return dst_input(skb) //根据结果是走转发还是进一步上传
	
|-->ip_route_input_noref //(net/ipv4/route.c) 路由选择
	|-->tos &= IPTOS_RT_MASK
	|-->rcu_read_lock() //加锁
	|-->ip_route_input_rcu(skb, daddr, saddr, tos, dev, &res)
	|-->rcu_read_unlock() //解锁
	
|-->ip_route_input_rcu //(net/ipv4/route.c)
	|-->if (ipv4_is_multicast(daddr)) //多播地址
		|-->struct in_device *in_dev = __in_dev_get_rcu(dev)
		|-->if (in_dev)
			|-->our = ip_check_mc_rcu(in_dev, daddr, saddr, ip_hdr(skb)->protocol)
			
		|-->if ((!in_dev || !our) && netif_is_l3_slave(dev))
			|-->l3_in_dev = __in_dev_get_rcu(skb->dev)
			|-->if (l3_in_dev)
				|-->our = ip_check_mc_rcu(l3_in_dev, daddr, saddr, ip_hdr(skb)->protocol)
				
		|-->if (our || (!ipv4_is_local_multicast(daddr) && IN_DEV_MFORWARD(in_dev)))
			|-->err = ip_route_input_mc(skb, daddr, saddr, tos, dev, our)
			
		|-->return err //如果多播地址，到此函数就结束了
			
	|-->ip_route_input_slow(skb, daddr, saddr, tos, dev, res)
	
|-->ip_route_input_slow //(net/ipv4/route.c) 路由选择
	|-->if (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr))
		|-->goto martian_source
		
	|-->if (ipv4_is_lbcast(daddr) || (saddr == 0 && daddr == 0))
		|-->goto brd_input
		
	|-->if (ipv4_is_zeronet(saddr))
		|-->goto martian_source
		
	|-->if (ipv4_is_zeronet(daddr))
		|-->goto martian_destination
		
	|-->if (ipv4_is_loopback(daddr))
		|-->if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))
			|-->goto martian_destination
	|-->else if (ipv4_is_loopback(saddr))
		|-->if (!IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))
			|-->goto martian_source
			
	|-->fib_lookup(net, &fl4, res, 0)
	|-->if (res->type == RTN_LOCAL)
		|-->fib_validate_source(skb, saddr, daddr, tos, 0, dev, in_dev, &itag)
		|-->goto local_input
		
|-->ip_rcv_options //(net/ipv4/ip_input.c) IP选项
	|-->skb_cow(skb, skb_headroom(skb)) //进行拷贝复制(写时拷贝)
	|-->iph = ip_hdr(skb)
	|-->opt = &(IPCB(skb)->opt)
	|-->opt->optlen = iph->ihl*4 - sizeof(struct iphdr)
	|-->ip_options_compile(dev_net(dev), opt, skb) //分析报头选项
	|-->if (unlikely(opt->srr))
		|-->ip_options_rcv_srr(skb) //
	
//ip选项处理情景1：入口封包
|-->ip_rcv
	|-->ip_rcv_finish
		|-->ip_rcv_options 
			|-->ip_options_compile
			|-->ip_options_rcv_srr
			
		|-->dst_input //数据包进一步传输
			|-->ip_forward //转发
				|-->ip_forward_finish
					|-->ip_forward_options
					|-->dst_output //出口
						|-->ip_output 
							|-->ip_fragment
								|-->ip_options_fragment
								
//ip选项处理情景2：本地产生的封包
|-->ip_queue_xmit / ip_push_pending_frames
	|-->ip_options_build
	|-->dst_output
	
	
|-->ip_options_compile //(net/ipv4/ip_options.c) ip option解析
	|-->if (skb)
		|-->rt = skb_rtable(skb)
		|-->optptr = (unsigned char *)&(ip_hdr(skb)[1])
	|-->else
		|-->optptr = opt->__data
		
	|-->iph = optptr - sizeof(struct iphdr)
	|-->for (l = opt->optlen; l > 0; )
	
	
|-->ip_forward //(net/ipv4/ip_forward.c) 数据转发
	|-->if (skb->pkt_type != PACKET_HOST)
		|-->goto drop
		
	|-->if (skb_warn_if_lro(skb))
		|-->goto drop
		
	|-->if (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb))
		|-->goto drop
		
	|-->if (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))
		|-->return NET_RX_SUCCESS
		
	|-->skb_forward_csum(skb)
	|-->net = dev_net(skb->dev)
	|-->if (ip_hdr(skb)->ttl <= 1)
		|-->goto too_many_hops
		
	|-->if (!xfrm4_route_forward(skb))
		|-->goto drop
		
	|-->rt = skb_rtable(skb)
	|-->if (opt->is_strictroute && rt->rt_uses_gateway)
		|-->goto sr_failed
		
	|-->IPCB(skb)->flags |= IPSKB_FORWARDED
	|-->mtu = ip_dst_mtu_maybe_forward(&rt->dst, true)
	|-->if (ip_exceeds_mtu(skb, mtu))
		|-->IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS)
		|-->icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu))
		|-->goto drop
		
	|-->if (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))
		|-->goto drop
		
	|-->iph = ip_hdr(skb)
	|-->ip_decrease_ttl(iph)
	|-->if (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr && !skb_sec_path(skb))
		|-->ip_rt_send_redirect(skb)
		
	|-->skb->priority = rt_tos2priority(iph->tos)
	|-->return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,
               net, NULL, skb, skb->dev, rt->dst.dev,
               ip_forward_finish)
			   
|-->ip_call_ra_chain //(net/ipv4/ip_input.c)
	|-->u8 protocol = ip_hdr(skb)->protocol
	|-->for (ra = rcu_dereference(ip_ra_chain); ra; ra = rcu_dereference(ra->next))
		|-->if (sk && inet_sk(sk)->inet_num == protocol &&
            (!sk->sk_bound_dev_if || sk->sk_bound_dev_if == dev->ifindex) && net_eq(sock_net(sk), net))
			|-->if (ip_is_fragment(ip_hdr(skb)))
				|-->if (ip_defrag(net, skb, IP_DEFRAG_CALL_RA_CHAIN))
					|-->return true
					
			|-->if (last)
				|-->struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC)
				|-->if (skb2)
					|-->raw_rcv(last, skb2)
					
			|-->last = sk